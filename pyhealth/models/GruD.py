import torch
import torch.nn as nn
import torch.nn.functional as F

from pyhealth.models import BaseModel
from pyhealth.datasets import SampleDataset


class DecayLayer(nn.Module):
    """Small helper layer for computing input and hidden decays."""

    def __init__(self, feature_dim: int, hidden_dim: int):
        super().__init__()
        self.gamma_x = nn.Parameter(torch.ones(feature_dim))
        self.gamma_h = nn.Parameter(torch.ones(hidden_dim))

    def forward(self, delta, h_prev):
        decay_x = torch.exp(-delta * F.relu(self.gamma_x))
        decay_h = torch.exp(-delta[:, :1] * F.relu(self.gamma_h))
        return decay_x, decay_h


class GRUD(BaseModel):
    """

    The GRUD model is simlar to the GRU model but handles irregular 
    time series data by reducing the influence of missing values.

    
    - Input arguments

    x: torch.Tensor
        Shape (batch_size, sequence_len, feature_dim). These are the
        measured values.
    m: torch.Tensor
        Shape (batch_size, sequence_len, feature_dim). A mask where 1 means
        observed and 0 means missing.
    delta: torch.Tensor
        Shape (batch_size, sequence_len, feature_dim). Time since last
        observation for each feature.
    label: torch.Tensor
        True labels for each patient.

    - Output arguments

    The function returns a dictionary with:
      "loss": torch.Tensor — training loss
      "y_prob": torch.Tensor — predicted probabilities
      "y_true": torch.Tensor — ground truth labels
      "raw_outputs": torch.Tensor — raw outputs before activation

    - Example use case
    
    model = GRUD(dataset=my_dataset, hidden_dim=32)
    out = model(x=batch_x, m=batch_m, delta=batch_delta, label=batch_y)
    loss = out["loss"]

    """

    def __init__(self, dataset: SampleDataset, hidden_dim: int = 32):
        super().__init__(dataset)

        self.feature_key = self.feature_keys[0]
        self.input_dim = dataset.input_processors[self.feature_key].size()
        self.hidden_dim = hidden_dim

        self.decay_layer = DecayLayer(self.input_dim, hidden_dim)
        self.gru_cell = nn.GRUCell(self.input_dim, hidden_dim)
        self.output_layer = nn.Linear(hidden_dim, self.get_output_size())

    def forward(self, **kwargs):
        x = kwargs[self.feature_key]
        m = kwargs["m"]
        delta = kwargs["delta"]

        y_true = kwargs[self.label_keys[0]].to(self.device)

        batch_size, seq_len, j = x.shape
        h = torch.zeros(batch_size, self.hidden_dim, device=x.device)
        x_first = x[:, 0]

        for t in range(seq_len):
            
            decay_x, decay_h = self.decay_layer(delta[:, t], h)
            x_t = m[:, t] * x[:, t] + (1 - m[:, t]) * (decay_x * x_first)
            h = self.gru_cell(x_t, h * decay_h)

        raw_outputs = self.output_layer(h)
        loss = self.get_loss_function()(raw_outputs, y_true)
        y_prob = self.prepare_y_prob(raw_outputs)

        return {
            "loss": loss,
            "y_prob": y_prob,
            "y_true": y_true,
            "raw_outputs": raw_outputs,
        }



# basic test case generated by an LLM

def test_grud_basic():
    # Small fake dataset with 2 patients and 4 time steps
    samples = [
        {
            "patient_id": "p0",
            "visit_id": "v0",
            "x": [[1.0], [2.0], [3.0], [4.0]],
            "m": [[1], [1], [1], [1]],
            "delta": [[0], [1], [1], [1]],
            "label": 0,
        },
        {
            "patient_id": "p1",
            "visit_id": "v1",
            "x": [[5.0], [2.0], [1.0], [0.5]],
            "m": [[1], [1], [1], [1]],
            "delta": [[0], [1], [1], [1]],
            "label": 1,
        },
    ]

    input_schema = {
        "x": "tensor",
        "m": "tensor",
        "delta": "tensor",
    }
    output_schema = {"label": "binary"}

    dataset = SampleDataset(
        samples=samples,
        input_schema=input_schema,
        output_schema=output_schema,
        dataset_name="test",
    )

    # Build batch tensors
    x = torch.tensor([s["x"] for s in samples]).float()
    m = torch.tensor([s["m"] for s in samples]).float()
    delta = torch.tensor([s["delta"] for s in samples]).float()
    y = torch.tensor([s["label"] for s in samples]).float()

    # Instantiate model
    model = GRUD(dataset=dataset, hidden_dim=8)

    # Run forward pass
    out = model(x=x, m=m, delta=delta, label=y)

    # Basic checks
    assert "loss" in out
    assert out["loss"].dim() == 0   # scalar loss

    print("GRU-D basic test passed:", out)


if __name__ == "__main__":
    test_grud_basic()
